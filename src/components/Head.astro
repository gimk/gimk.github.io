---
// Import global styles and fonts
import "../styles/global.css";
import "@fontsource/dm-sans/latin-400.css";
import "@fontsource/dm-sans/latin-500.css";
import "@fontsource/fraunces/latin-400.css";
import "@fontsource/fraunces/latin-600.css";
import "@fontsource/jetbrains-mono/latin-400.css";
import "@fontsource/jetbrains-mono/latin-600.css";
import { ClientRouter } from "astro:transitions";
// Deprecated : import { ViewTransitions } from "astro:transitions";

// Define component props
interface Props {
  title: string;
  description: string;
  image?: string;
}

// Determine the canonical URL
const canonicalURL = new URL(Astro.url.pathname, Astro.site);

// Destructure props with default image
const { title, description, image = "/nano.png" } = Astro.props;
---

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link
  rel="icon"
  type="image/svg+xml"
  href="/favicon-dark.svg"
  media="(prefers-color-scheme: dark)"
/>
<link
  rel="icon"
  type="image/svg+xml"
  href="/favicon-light.svg"
  media="(prefers-color-scheme: light)"
/>

<meta name="generator" content={Astro.generator} />
<meta name="theme-color" />

<link rel="canonical" href={canonicalURL} />

<link rel="sitemap" href="/sitemap-index.xml" />

<title>{title}</title>
<meta name="title" content={title} />
<meta name="description" content={description} />

<meta property="og:type" content="website" />
<meta property="og:url" content={Astro.url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={new URL(image, Astro.url)} />

<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={new URL(image, Astro.url)} />

<ClientRouter />

<script>
  // This script runs only once on initial load for View Transitions
  import type { TransitionBeforeSwapEvent } from "astro:transitions/client";
  document.addEventListener("astro:before-swap", (e) =>
    [
      // Select all font preload links in the incoming document's head
      ...(e as TransitionBeforeSwapEvent).newDocument.head.querySelectorAll(
        "link[as=\"font\"]"
      ),
      // Remove each found link to prevent duplicate preloading issues
    ].forEach((link) => link.remove())
  );
</script>

<script is:inline>
  // Declare state variables in a scope accessible across init calls
  let blinkTimeoutId = null; // Timeout ID for pig blinking animation
  let pigAnimationLoopId = null; // RequestAnimationFrame ID for pig movement loop
  let isWiggling = false; // State flag for pig wiggle animation

  // Function to add 'show' class to elements for staggered animation
  function animate() {
    const animateElements = document.querySelectorAll(".animate");
    animateElements.forEach((element, index) => {
      setTimeout(() => {
        element.classList.add("show");
      }, index * 150); // Stagger animation start time
    });
  }

  // Function to add/remove 'scrolled' class based on scroll position
  function onScroll() {
    if (window.scrollY > 0) {
      document.documentElement.classList.add("scrolled");
    } else {
      document.documentElement.classList.remove("scrolled");
    }
  }

  // Function to smoothly scroll the page to the top
  function scrollToTop(event) {
    event.preventDefault(); // Prevent default link behavior
    window.scrollTo({
      top: 0,
      behavior: "smooth", // Enable smooth scrolling
    });
  }

  // Function to toggle dark/light theme instantly (avoids transition flicker)
  function toggleTheme(dark, disableTransitions = true) {
    let css = null;
    if (disableTransitions) {
      // Create a temporary style element to disable all transitions
      css = document.createElement("style");
      css.appendChild(
        document.createTextNode(
          `* {
             -webkit-transition: none !important;
             -moz-transition: none !important;
             -o-transition: none !important;
             -ms-transition: none !important;
             transition: none !important;
          }`
        )
      );
      document.head.appendChild(css);
    }

    // Add or remove the 'dark' class from the root element
    if (dark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }

    if (disableTransitions) {
      // Force browser reflow to apply changes immediately before removing the style override
      window.getComputedStyle(css).opacity;
      document.head.removeChild(css);
    }
  }

  // Function to apply the theme based on localStorage or system preference on initial load
  function preloadTheme() {
    const userTheme = localStorage.theme;
    const themeColorMeta = document.querySelector("meta[name=\"theme-color\"]");
    // Determine if dark mode should be enabled
    const isDark =
      userTheme === "dark" ||
      (userTheme !== "light" && // Check if no explicit light theme is set
        window.matchMedia("(prefers-color-scheme: dark)").matches); // Check system preference
    toggleTheme(isDark); // Apply the theme
    // Update the theme-color meta tag for browser UI consistency
    if (themeColorMeta) {
      themeColorMeta.setAttribute("content", isDark ? "#020617" : "#fff7ed");
    }
  }

  // --- Main Initialization function ---
  // This function sets up event listeners and starts animations.
  // It's called on initial load and after Astro view transitions.
  function init() {
    console.log("Running init()..."); // Log init execution for debugging

    // --- Initial Setup: Theme, Scroll Behavior, Entry Animations ---
    preloadTheme(); // Set the theme immediately
    onScroll(); // Check initial scroll position
    animate(); // Start entry animations

    // --- Event Listener Setup ---

    // Back to Top Button
    const backToTop = document.getElementById("back-to-top");
    // Remove existing listener to prevent duplicates on swaps, then add it
    backToTop?.removeEventListener("click", scrollToTop);
    backToTop?.addEventListener("click", scrollToTop); // Use named function directly

    // Back to Previous Page Button (e.g., on a blog post)
    const backToPrev = document.getElementById("back-to-prev");
    // Add listener only if it hasn't been added before (using a data attribute)
    if (backToPrev && !backToPrev.hasAttribute("data-listener-added")) {
      backToPrev.addEventListener("click", () => window.history.back());
      backToPrev.setAttribute("data-listener-added", "true"); // Mark as added
    }

    // Theme Toggle Button
    const themeColorMeta = document.querySelector("meta[name=\"theme-color\"]");
    const toggleThemeButton = document.getElementById("theme-button");
    // Add listener only if it hasn't been added before
    if (
      toggleThemeButton &&
      !toggleThemeButton.hasAttribute("data-listener-added")
    ) {
      toggleThemeButton.addEventListener("click", () => {
        const isDark = document.documentElement.classList.contains("dark");
        if (isDark) {
          // Switch to light theme
          localStorage.setItem("theme", "light");
          themeColorMeta?.setAttribute("content", "#fff7ed");
          toggleTheme(false, false);
        } else {
          // Switch to dark theme
          localStorage.setItem("theme", "dark");
          themeColorMeta?.setAttribute("content", "#020617");
          toggleTheme(true, false);
        }
      });
      toggleThemeButton.setAttribute("data-listener-added", "true"); // Mark as added
    }

    // Scroll Listener for header styling changes
    // Remove existing listener before adding to prevent duplicates
    document.removeEventListener("scroll", onScroll);
    document.addEventListener("scroll", onScroll);

    // --- PIG ANIMATION SETUP ---
    // Get references to SVG elements
    const svg = document.querySelector(".cochon-svg");
    const head = document.getElementById("head");
    const snoutGroup = document.getElementById("snout-group");
    const leftEar = document.getElementById("left-ear");
    const rightEar = document.getElementById("right-ear");
    const leftEye = document.getElementById("left-eye");
    const rightEye = document.getElementById("right-eye");

    // Error handling: Check if all required SVG elements are present
    if (
      !svg ||
      !head ||
      !snoutGroup ||
      !leftEar ||
      !rightEar ||
      !leftEye ||
      !rightEye
    ) {
      console.error(
        "Error: One or more Pig SVG elements not found! Pig animation cannot run."
      );
      // Optionally, hide the SVG or related elements if parts are missing
      // if (svg) svg.style.display = 'none';
      return; // Exit init if elements are missing
    }

    // Store original positions/attributes for reference and reset
    const leftEyeOrigX = parseFloat(leftEye.getAttribute("cx") || "0");
    const leftEyeOrigY = parseFloat(leftEye.getAttribute("cy") || "0");
    const rightEyeOrigX = parseFloat(rightEye.getAttribute("cx") || "0");
    const rightEyeOrigY = parseFloat(rightEye.getAttribute("cy") || "0");
    const eyeOriginalRy = parseFloat(leftEye.getAttribute("ry") || "4"); // Default Ry if not set

    // --- Animation Configuration ---

    // Parallax Effect Configuration (how much each part moves relative to mouse)
    const maxSnoutOffset = 1;  // Snout moves the most
    const maxEyeOffset = 0.8;    // Eyes
    const maxHeadOffset = 0.5;   // Head
    const maxEarOffset = 0.2;    // Ears

    // Smoothing / Interpolation (Lerp) Setup (makes movement smoother)
    const smoothingFactor = 0.2; // Lower value = smoother, slower response
    let targetSnoutTx = 0,
      targetSnoutTy = 0,
      targetSnoutRotation = 0; // Target positions/rotation based on mouse
    let targetHeadTx = 0,
      targetHeadTy = 0;
    let targetLeftEarTx = 0,
      targetLeftEarTy = 0;
    let targetRightEarTx = 0,
      targetRightEarTy = 0;
    let targetLeftEyeCx = leftEyeOrigX,
      targetLeftEyeCy = leftEyeOrigY;
    let targetRightEyeCx = rightEyeOrigX,
      targetRightEyeCy = rightEyeOrigY;
    let currentSnoutTx = 0,
      currentSnoutTy = 0,
      currentSnoutRotation = 0; // Current interpolated positions/rotation
    let currentHeadTx = 0,
      currentHeadTy = 0;
    let currentLeftEarTx = 0,
      currentLeftEarTy = 0;
    let currentRightEarTx = 0,
      currentRightEarTy = 0;
    let currentLeftEyeCx = leftEyeOrigX,
      currentLeftEyeCy = leftEyeOrigY;
    let currentRightEyeCx = rightEyeOrigX,
      currentRightEyeCy = rightEyeOrigY;

    // Wiggle Effect Configuration (when mouse is close)
    const wiggleThreshold = 60; // Pixels distance from SVG center to trigger wiggle
    const wiggleAmplitude = 6; // Max horizontal movement during wiggle (SVG units)
    const wiggleFrequency = 0.025; // Speed of the wiggle (radians per millisecond)
    // isWiggling state is declared outside init

    // Blinking Animation Configuration
    const blinkDuration = 100; // Milliseconds the eyes stay closed
    const blinkRyValue = 1; // The 'ry' attribute value for closed eyes (makes them thin)
    const minBlinkInterval = 5000; // Minimum time between blinks (ms)
    const maxBlinkInterval = 8000; // Maximum time between blinks (ms)
    // blinkTimeoutId is declared outside init

    // --- Pig Animation Logic Functions ---

    // Function to update TARGET positions based on mouse movement and check for wiggle proximity
    function updatePigState(event) {
      if (!svg) return; // Ensure SVG element exists

      const mouseX = event.clientX;
      const mouseY = event.clientY;
      const svgRect = svg.getBoundingClientRect(); // Get SVG position and size
      const svgCenterX = svgRect.left + svgRect.width / 2;
      const svgCenterY = svgRect.top + svgRect.height / 2;
      const deltaX = mouseX - svgCenterX; // Distance from mouse to SVG center X
      const deltaY = mouseY - svgCenterY; // Distance from mouse to SVG center Y

      // Check proximity for wiggle trigger
      const distance = Math.sqrt(deltaX ** 2 + deltaY ** 2);
      isWiggling = distance < wiggleThreshold; // Update wiggle state flag

      // Calculate normalized offsets (-1 to 1) based on mouse position relative to SVG center
      const normalizedOffsetX = svgRect.width
        ? deltaX / (svgRect.width / 2)
        : 0;
      const normalizedOffsetY = svgRect.height
        ? deltaY / (svgRect.height / 2)
        : 0;

      // Calculate TARGET translation and rotation values for parallax effect
      targetSnoutTx = normalizedOffsetX * maxSnoutOffset;
      targetSnoutTy = normalizedOffsetY * maxSnoutOffset;
      targetSnoutRotation = Math.max(-15, Math.min(15, normalizedOffsetX * -0.4)); // Rotate snout slightly (degrees), clamped to prevent spinning
      targetHeadTx = normalizedOffsetX * maxHeadOffset;
      targetHeadTy = normalizedOffsetY * maxHeadOffset;
      
      // 3D Spherical Rotation Effect
      // We tilt the vertical position of left vs right components based on horizontal look direction
      // This mimics drawing along the curved surface of a sphere.
      const ear3dTilt = normalizedOffsetX * 0.2;
      const eye3dTilt = normalizedOffsetX * 0.1;

      targetLeftEarTx = normalizedOffsetX * maxEarOffset;
      targetLeftEarTy = (normalizedOffsetY * maxEarOffset) + ear3dTilt;
      targetRightEarTx = normalizedOffsetX * maxEarOffset;
      targetRightEarTy = (normalizedOffsetY * maxEarOffset) - ear3dTilt;
      
      const targetLeftEyeTx = normalizedOffsetX * maxEyeOffset;
      const targetLeftEyeTy = (normalizedOffsetY * maxEyeOffset) + eye3dTilt;
      const targetRightEyeTx = normalizedOffsetX * maxEyeOffset;
      const targetRightEyeTy = (normalizedOffsetY * maxEyeOffset) - eye3dTilt;

      // Eyes follow the independent eye parallax movement
      targetLeftEyeCx = leftEyeOrigX + targetLeftEyeTx;
      targetLeftEyeCy = leftEyeOrigY + targetLeftEyeTy;
      targetRightEyeCx = rightEyeOrigX + targetRightEyeTx;
      targetRightEyeCy = rightEyeOrigY + targetRightEyeTy;
    }

    // --- Main Pig Animation Loop (called by requestAnimationFrame) ---
    let lastPigFrameTime = 0;
    const PIG_FPS = 30;
    const PIG_FRAME_TIME = 1000 / PIG_FPS;

    function pigAnimationLoop(timestamp) {
      // Throttle FPS
      const elapsed = timestamp - lastPigFrameTime;
      if (elapsed < PIG_FRAME_TIME) {
        pigAnimationLoopId = requestAnimationFrame(pigAnimationLoop);
        return;
      }
      lastPigFrameTime = timestamp;

      // Interpolate (lerp) current positions towards target positions for smooth movement
      const snoutDx = (targetSnoutTx - currentSnoutTx) * smoothingFactor;
      const snoutDy = (targetSnoutTy - currentSnoutTy) * smoothingFactor;
      const snoutDr = (targetSnoutRotation - currentSnoutRotation) * smoothingFactor;
      const headDx = (targetHeadTx - currentHeadTx) * smoothingFactor;
      const headDy = (targetHeadTy - currentHeadTy) * smoothingFactor;
      const leftEarDx = (targetLeftEarTx - currentLeftEarTx) * smoothingFactor;
      const leftEarDy = (targetLeftEarTy - currentLeftEarTy) * smoothingFactor;
      const rightEarDx = (targetRightEarTx - currentRightEarTx) * smoothingFactor;
      const rightEarDy = (targetRightEarTy - currentRightEarTy) * smoothingFactor;
      const eyeLDx = (targetLeftEyeCx - currentLeftEyeCx) * smoothingFactor;
      const eyeLDy = (targetLeftEyeCy - currentLeftEyeCy) * smoothingFactor;
      const eyeRDx = (targetRightEyeCx - currentRightEyeCx) * smoothingFactor;
      const eyeRDy = (targetRightEyeCy - currentRightEyeCy) * smoothingFactor;

      currentSnoutTx += snoutDx;
      currentSnoutTy += snoutDy;
      currentSnoutRotation += snoutDr;
      currentHeadTx += headDx;
      currentHeadTy += headDy;
      currentLeftEarTx += leftEarDx;
      currentLeftEarTy += leftEarDy;
      currentRightEarTx += rightEarDx;
      currentRightEarTy += rightEarDy;
      currentLeftEyeCx += eyeLDx;
      currentLeftEyeCy += eyeLDy;
      currentRightEyeCx += eyeRDx;
      currentRightEyeCy += eyeRDy;

      // Convergence check: if all deltas are tiny and not wiggling, we can potentially pause
      // But for simplicity and to keep the wiggle active, we'll just keep it throttled for now.
      // To really save CPU, we'd stop the loop if mouse hasn't moved.

      // Calculate wiggle offset if the mouse is close enough
      let wiggleOffset = 0;
      if (isWiggling) {
        // Use sine wave based on time for smooth back-and-forth wiggle
        wiggleOffset = Math.sin(Date.now() * wiggleFrequency) * wiggleAmplitude;
      }

      // Apply the calculated (interpolated + wiggle) positions to the SVG elements
      if (head && snoutGroup && leftEar && rightEar && leftEye && rightEye) {
        head.setAttribute(
          "transform",
          `translate(${currentHeadTx + wiggleOffset} ${currentHeadTy})`
        );
        snoutGroup.setAttribute(
          "transform",
          `translate(${currentSnoutTx + wiggleOffset} ${currentSnoutTy}) rotate(${currentSnoutRotation} 100.5 132.5)`
        );
        leftEar.setAttribute(
          "transform",
          `translate(${currentLeftEarTx + wiggleOffset} ${currentLeftEarTy})`
        );
        rightEar.setAttribute(
          "transform",
          `translate(${currentRightEarTx + wiggleOffset} ${currentRightEarTy})`
        );

        leftEye.setAttribute(
          "cx",
          (currentLeftEyeCx + wiggleOffset).toString()
        );
        leftEye.setAttribute("cy", currentLeftEyeCy.toString());
        rightEye.setAttribute(
          "cx",
          (currentRightEyeCx + wiggleOffset).toString()
        );
        rightEye.setAttribute("cy", currentRightEyeCy.toString());
      }

      // Request the next frame to continue the animation loop
      pigAnimationLoopId = requestAnimationFrame(pigAnimationLoop);
    }

    // --- Blinking Functions ---

    // Function to trigger a single blink animation
    function triggerBlink() {
      if (!leftEye || !rightEye) return; // Ensure eyes exist
      // Set eye radius Y (ry) to make them thin (closed)
      leftEye.setAttribute("ry", blinkRyValue.toString());
      rightEye.setAttribute("ry", blinkRyValue.toString());
      // Set a timeout to open the eyes back up
      setTimeout(() => {
        if (!leftEye || !rightEye) return; // Check again in case of navigation during blink
        // Restore original eye radius Y
        leftEye.setAttribute("ry", eyeOriginalRy.toString());
        rightEye.setAttribute("ry", eyeOriginalRy.toString());
        // Schedule the next blink after this one finishes
        scheduleNextBlink();
      }, blinkDuration);
    }

    // Function to schedule the next blink with a random delay
    function scheduleNextBlink() {
      // Clear any existing blink timeout to prevent multiple timers
      if (blinkTimeoutId !== null) {
        clearTimeout(blinkTimeoutId);
      }
      // Calculate a random delay within the defined min/max interval
      const randomDelay =
        Math.random() * (maxBlinkInterval - minBlinkInterval) +
        minBlinkInterval;
      // Set the timeout for the next blink
      blinkTimeoutId = window.setTimeout(triggerBlink, randomDelay);
    }

    // --- Start Pig Animation and Listeners ---

    // Mousemove listener to update target positions and wiggle state
    // Remove first to avoid duplicates if init runs multiple times
    document.removeEventListener("mousemove", updatePigState);
    document.addEventListener("mousemove", updatePigState);

    // Remove any potential old click listeners if they existed
    // svg.removeEventListener("click", window.handlePigClick); // Example if you had one

    // Cancel any previous animation frame loop before starting a new one
    if (pigAnimationLoopId !== null) {
      cancelAnimationFrame(pigAnimationLoopId);
      pigAnimationLoopId = null; // Reset the ID
    }
    pigAnimationLoop(performance.now()); // Start the main animation loop

    // Start the blinking cycle
    scheduleNextBlink();
  } // --- End of init() function ---

  // --- Initial Page Load and Astro Navigation Hooks ---
  // Run init() when the DOM is fully loaded initially
  document.addEventListener("DOMContentLoaded", init);
  // Run init() after Astro swaps content during view transitions
  document.addEventListener("astro:after-swap", init);
  // Preload theme on initial load (before DOMContentLoaded potentially)
  // This helps prevent flashing of the wrong theme
  preloadTheme();
</script>
