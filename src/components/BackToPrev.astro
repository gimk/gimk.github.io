---
type Props = {
  href: string;
  hideShadow?: boolean;
  hideBorder?: boolean;
};

const { href, hideShadow = false, hideBorder = false } = Astro.props;
---

<div class={hideShadow ? "" : "shadow-ascii"}>
  <a
    href={href}
    class={`back-to-prev relative group w-full flex items-center pr-3 transition-all duration-300 ease-in-out h-20 overflow-hidden group-hover:text-orange-500 dark:group-hover:text-orange-500 bg-[#faf9f6] dark:bg-slate-950 ${hideBorder ? "" : "border border-black/10 dark:border-white/10"}`}
  >
  <div
    class="absolute inset-0 pointer-events-none overflow-hidden opacity-0 group-hover:opacity-[55%] dark:group-hover:opacity-[30%] transition-opacity duration-300"
    aria-hidden="true"
  >
    <pre
      class="ascii-canvas font-mono text-[8px] leading-[6px] tracking-[1px] text-orange-500 dark:text-orange-500 absolute top-1/2 left-[16px] -translate-x-1/2 -translate-y-1/2 scale-75"
      style="mask-image: radial-gradient(ellipse at center, black 20%, transparent 50%); -webkit-mask-image: radial-gradient(ellipse at center, black 20%, transparent 50%);"
    ></pre>
  </div>
  <div class="flex items-center pl-10">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      class="absolute top-1/2 left-4 -translate-y-1/2 size-4 stroke-2 fill-none stroke-current group-hover:stroke-orange-500 transition-colors duration-300"
    >
      <line
        x1="5"
        y1="12"
        x2="19"
        y2="12"
        class="translate-x-2 group-hover:translate-x-0 scale-x-0 group-hover:scale-x-100 transition-transform duration-300 ease-in-out"
      ></line>
      <polyline
        points="12 5 5 12 12 19"
        class="translate-x-1 group-hover:translate-x-0 transition-transform duration-300 ease-in-out"
      ></polyline>
    </svg>
    <div class="text-sm font-medium transition-all duration-300">
      <slot />
    </div>
  </div>
  </a>
</div>
<script>
  function initBackToPrevAscii() {
    const links = document.querySelectorAll(".back-to-prev");

    links.forEach((link) => {
      const canvas = link.querySelector(".ascii-canvas") as HTMLPreElement;
      if (!canvas) return;

      let frameId: number;
      let time = 0;
      let lastTime = 0;
      const FPS_LIMIT = 24;
      const FRAME_MIN_TIME = 1000 / FPS_LIMIT;
      const density = " .:-=+*#%@";
      const cols = 200; // Restored original density
      const rows = 40; // Restored original density
      let isVisible = true;

      const observer = new IntersectionObserver(
        ([entry]) => {
          isVisible = entry.isIntersecting;
        },
        { threshold: 0 },
      );
      observer.observe(link);

      function render(timestamp: number) {
        if (!isVisible) {
          frameId = requestAnimationFrame(render);
          return;
        }

        // Throttle FPS
        const elapsed = timestamp - lastTime;
        if (elapsed < FRAME_MIN_TIME) {
          frameId = requestAnimationFrame(render);
          return;
        }
        lastTime = timestamp;

        let output = "";
        const cx = cols / 2;
        const cy = rows / 2;

        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const dx = (x - cx) * 0.6;
            const dy = y - cy;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const wave =
              Math.sin(distance * 0.3 - time) * 0.6 +
              Math.cos(dx * 0.15 + time * 0.8) * 0.2 +
              Math.sin(dy * 0.15 + time * 0.8) * 0.2;

            const normalized = (wave + 1) / 2;
            let charIndex = Math.floor(normalized * density.length);
            charIndex = Math.max(0, Math.min(density.length - 1, charIndex));
            output += density[charIndex];
          }
          output += "\n";
        }

        canvas.textContent = output;
        time += 0.05; // Adjusted for lower FPS
        frameId = requestAnimationFrame(render);
      }

      link.addEventListener("mouseenter", () => {
        frameId = requestAnimationFrame(render);
      });

      link.addEventListener("mouseleave", () => {
        cancelAnimationFrame(frameId);
      });
    });
  }

  // Initialize on load
  initBackToPrevAscii();
  // Initialize after view transitions
  document.addEventListener("astro:after-swap", initBackToPrevAscii);
</script>
