<div
  id="ascii-container"
  class="absolute inset-0 pointer-events-none -z-20 overflow-hidden select-none opacity-10 dark:opacity-5"
  aria-hidden="true"
>
  <div class="mx-auto max-w-screen-xl px-5 h-full w-full relative">
    <div
      class="absolute -top-[600px] left-1/2 -translate-x-1/2 md:left-[15%] md:-translate-x-1/2"
    >
      <pre
        id="ascii-canvas"
        class="font-mono text-[10px] leading-[8px] tracking-[1px] text-accent-primary"
        style="mask-image: radial-gradient(ellipse at center, black 20%, transparent 70%); -webkit-mask-image: radial-gradient(ellipse at center, black 20%, transparent 70%);">
      </pre>
    </div>
  </div>
</div>

<script>
  let frameId: number;
  let lastTime = 0;
  const FPS_LIMIT = 24;
  const FRAME_MIN_TIME = 1000 / FPS_LIMIT;

  function initAscii() {
    const canvas = document.getElementById(
      "ascii-canvas"
    ) as HTMLPreElement | null;
    const container = document.getElementById("ascii-container");
    if (!canvas || !container) return;

    // Stop any existing animation
    if (frameId) {
      cancelAnimationFrame(frameId);
    }

    const density = " .:-=+*#%@";
    // Restored original dimensions for high-density look
    const cols = 400;
    const rows = 300;
    let time = 0;
    let isVisible = true;

    // Pause when not in view
    const observer = new IntersectionObserver(
      ([entry]) => {
        isVisible = entry.isIntersecting;
      },
      { threshold: 0 },
    );
    observer.observe(container);

    function render(timestamp: number) {
      if (!isVisible) {
        frameId = requestAnimationFrame(render);
        return;
      }

      // Throttle FPS
      const elapsed = timestamp - lastTime;
      if (elapsed < FRAME_MIN_TIME) {
        frameId = requestAnimationFrame(render);
        return;
      }
      lastTime = timestamp;

      let output = "";
      const cx = cols / 2;
      const cy = rows / 2;

      for (let y = 0; y <= rows - 1; y++) {
        for (let x = 0; x <= cols - 1; x++) {
          const dx = (x - cx) * 0.6;
          const dy = y - cy;
          const distance = Math.sqrt(dx * dx + dy * dy);

          const wave =
            Math.sin(distance * 0.15 - time) * 0.6 +
            Math.cos(dx * 0.08 + time * 0.5) * 0.2 +
            Math.sin(dy * 0.08 + time * 0.5) * 0.2;

          const normalized = (wave + 1) / 2;
          let charIndex = Math.floor(normalized * density.length);
          charIndex = Math.max(0, Math.min(density.length - 1, charIndex));
          output += density[charIndex];
        }
        output += "\n";
      }

      if (canvas) {
        canvas.textContent = output;
      }
      // Adjusted time increment for the lower FPS to keep motion speed consistent
      time += 0.02;
      frameId = requestAnimationFrame(render);
    }

    frameId = requestAnimationFrame(render);
  }

  // Initialize on load
  initAscii();
  // Initialize after view transitions
  document.addEventListener("astro:after-swap", initAscii);
</script>
